/**
 * Script for the visualizer webpage.
 */

$(document).ready(function(){
    // Register the file-loading event
    visualizer = new Visualizer('.file-input', '.day-control', '#view');
})

//--------------------//
// File reading stuff //
//--------------------//

/// Handler passed to the file selector, called when a file is selected.
function readSingleFile(f, handler) {
    var file = f.target.files[0];
    if (!file) {
        console.log("File not found!");
        return;
    }
    var reader = new FileReader();
    reader.onload = handler;
    reader.readAsText(file);
}

/// Cleans up the JSON that boost generated by parsing strings back to numerics where needed.
function cleanData(data){
    for(i in data.towns){
        town = data.towns[i];
        town.size = parseInt(town.size);
        town.lat = parseFloat(town.lat);
        town.long = parseFloat(town.long);
    }
    for(i in data.days){
        day = data.days[i];
        for(town in day)
            day[town] = parseInt(day[town]);
    }
}


//------------//
// Class: RGB //
//------------//

var RGB = function(r=0,g=0,b=0){
    this.r = r;
    this.g = g;
    this.b = b;
}

RGB.prototype.mix = function(other, p){
    var out = new RGB();
    out.r = this.r * p + other.r * (1 - p);
    out.g = this.g * p + other.g * (1 - p);
    out.b = this.b * p + other.b * (1 - p);
    return out;
}

RGB.prototype.toString = function(){
    return "rgb(" + Math.round(this.r) + "," + Math.round(this.g) + "," + Math.round(this.b) + ")";
}


//-----------------//
// Class: Gradient //
//-----------------//

function ValCol(val, colour){
    return {val: val, colour: colour};
}

var Gradient = function(colourMap){
    // colourMap is a List[Dict{val, colour}] sorted by increasing val
    this.colourMap = colourMap;
}

Gradient.prototype.get = function(val){
    // Check the upper and lower bounds first
    if(val <= this.colourMap[0].val)
        return this.colourMap[0].colour;
    if(val >= this.colourMap[this.colourMap.length-1].val)
        return this.colourMap[this.colourMap.length-1].colour;

    // It has to be somewhere in the gradient
    for(i in this.colourMap){
        upper = this.colourMap[i];
        if( val == upper.val)
            return upper.colour;
        if( val < upper.val ){
            lower = this.colourMap[i-1];
            p = (upper.val - val) / (upper.val - lower.val);
            return lower.colour.mix(upper.colour, p);
        }
    }
}

// Creates a new scaled gradient.
Gradient.prototype.scale = function(scale){
    var newMap = [];
    for(i in this.colourMap){
        newMap.push(ValCol(this.colourMap[i].val * scale, this.colourMap[i].colour));
    }
    return new Gradient(newMap);
}


// black -> red -> yellow -> white
var heatMap = new Gradient([
    ValCol(0,   new RGB(0,0,0)),
    ValCol(1/3, new RGB(255,0,0)),
    ValCol(2/3, new RGB(255,255,0)),
    ValCol(1,   new RGB(255,255,255)),
]);

// cyan -> blue -> black -> red -> yellow -> white
var superHeatMap = new Gradient([
    ValCol(0,   new RGB(0,255,255)),
    ValCol(1/5, new RGB(0,0,255)),
    ValCol(2/5, new RGB(0,0,0)),
    ValCol(3/5, new RGB(255,0,0)),
    ValCol(4/5, new RGB(255,255,0)),
    ValCol(1,   new RGB(255,255,255)),
]);

// dark blue -> deep purple -> red -> yellow -> white
var ultraHeatMap = new Gradient([
    ValCol(0,   new RGB(0,0,80)),
    ValCol(1/4, new RGB(128,0,128)),
    ValCol(2/4, new RGB(255,0,0)),
    ValCol(3/4, new RGB(255,230,0)),
    ValCol(1,   new RGB(255,255,255)),
]);

// red -> yellow -> green -> cyan -> blue -> purple
var rainbow = new Gradient([
    ValCol(0,   new RGB(255,0,0)),
    ValCol(1/5, new RGB(255,255,0)),
    ValCol(2/5, new RGB(0,255,0)),
    ValCol(3/5, new RGB(0,255,255)),
    ValCol(4/5, new RGB(0,0,255)),
    ValCol(1,   new RGB(255,0,255)),
]);

// black -> white
var monochrome = new Gradient([
    ValCol(0,   new RGB(0)),
    ValCol(1,   new RGB(255,255,255)),
]);

Gradient.gradients = {heatMap: heatMap, superHeatMap: superHeatMap, ultraHeatMap: ultraHeatMap, rainbow: rainbow, monochrome: monochrome};


//------------//
// Class: Map //
//------------//

/// Make a new Map by the following attributes
/// imageRef: ref to the map image
/// ratio: horizontal/vertical ratio of the image
/// min/maxLat/Long: bounding box of the map image
var Map = function(name, imageRef, imageRatio, minLat, maxLat, minLong, maxLong, overflow=false){
    this.name = name;
    this.imageRef = imageRef;
    this.imageRatio = imageRatio;
    this.box = {minLat: minLat, maxLat: maxLat, minLong: minLong, maxLong: maxLong};
}

/// Test if the given box fits inside the map.
Map.prototype.containsBox = function(box){
    if(this.box.minLat > box.minLat)
        return false;
    if(this.box.maxLat < box.maxLat)
        return false;
    if(this.box.minLong > box.minLong)
        return false;
    if(this.box.maxLong < box.maxLong)
        return false;
    return true;
}

// Returns a {width, height} object that matches the image's ratio that fits inside the given width and height
Map.prototype.fitTo = function(width, height){
    if(this.imageRatio > width/height)
        return {width: width, height: width / this.imageRatio};
    if(this.imageRatio < width/height)
        return {width: height * this.imageRatio, height: height};
    return {width: width, height: height};
}

Map.belgium = new Map("Belgium", "resource/belgium.svg", 1135.92/987.997, 49.2, 51.77, 2.19, 6.87);
// Todo: Figure out smarter map-to-dot algorithms for non-mercator projections.

Map.maps = [Map.belgium];


//-------------------//
// Class: Visualizer //
//-------------------//

/// Make a new Visualizer bound to the given elements.
var Visualizer = function(inputSelector, controlSelector, viewSelector){
    // Place our hook into the file selector
    $(inputSelector).on('change', f => readSingleFile(f, this.handleFile.bind(this)));
    // Place our hooks into the controls
    this.initializeControls(controlSelector);
    // Remember our view
    this.$view = $(viewSelector);
}

/// Bind into the controls and set the appropriate events.
Visualizer.prototype.initializeControls = function (controlSelector){
    $c = $(controlSelector);
    var c = this.control = Object();

    // Find the input elements.
    c.$prevDay = $c.find('.prev-day');
    c.$nextDay = $c.find('.next-day');
    c.$range = $c.find('.range-input');
    c.$run = $c.find('.run-input');
    c.$loop = $c.find('.loop-input');
    c.$gradient = $('.gradient-input');

    // Used for enabling-disabling all at once
    c.all = [c.$prevDay, c.$nextDay, c.$range, c.$run, c.$loop, c.$gradient.find("button")];

    // Bind events
    c.$prevDay.on("click", this.prevDay.bind(this));
    c.$nextDay.on("click", this.nextDay.bind(this));
    c.$range.on("input", () => this.updateDay(parseInt(c.$range.val())));
    c.$run.on("change", () => {if(c.$run.prop("checked")) this.run()});

    // Disable the controls, they're not ready yet.
    this.disableControls();
}

/// Automatically step through the different days of the simulation.
Visualizer.prototype.run = async function(){
    this.runSpeed = 60;
    var $run = this.control.$run;
    var $loop = this.control.$loop;

    while($run.prop("checked")){
        var nextDay = this.day + 1;
        if( nextDay >= this.maxDays ){
            if($loop.prop("checked")){
                nextDay = 0;
            } else {
                $run.prop("checked", false);
                break;
            }
        }
        this.updateDay(nextDay);
        await sleep(this.runSpeed);
    }
}

/// Set up and enable the controls based on the simulation data.
Visualizer.prototype.configureControls = function(){
    // Set the slider range
    this.control.$range.prop("max", this.maxDays);

    // Set the different options in the gradient selector
    var $target = this.control.$gradient.find(".dropdown-menu");
    $target.html("");

    // let because we're trying to bind gradient to a lambda later
    for(let gradient in Gradient.gradients){
        var $a = $("<a>");
        $a.text(gradient);

        $a.on("click", () => this.selectGradient(gradient))

        var $li = $("<li>");
        $li.append($a);
        $target.append($li);
    }

    // Enable the controls
    this.disableControls(false);
}

/// Select the gradient by the given name.
Visualizer.prototype.selectGradient = function(name){
    console.log(name);
    this.gradient = Gradient.gradients[name].scale(this.maxSingle);
    this.updateLegend();
    this.updateMap();
}

/// Control interface methods:
Visualizer.prototype.prevDay = function(){ this.updateDay(visualizer.day - 1); }
Visualizer.prototype.nextDay = function(){ this.updateDay(visualizer.day + 1); }

/// Enable or disable the controls.
Visualizer.prototype.disableControls = function(val=true){
    for(i in this.control.all)
        this.control.all[i].prop("disabled", val);
}

/// Handler passed to the FileReader, called with the contents of the selected file.
Visualizer.prototype.handleFile = function(e) {
    var data = JSON.parse(e.target.result);
    cleanData(data);
    this.initialize(data);
}

/// Actually initialize the Visualizer with the data retrieved from the file.
Visualizer.prototype.initialize = function(data){
    // Grab the data parsed from the file and aggregate it
    this.days = data.days;
    this.towns = data.towns;
    this.aggregateData();

    // Put the total number of days
    this.maxDays = this.days.length;
    $('.days').text(this.maxDays);
    
    // set up the view
    this.makeView();
    this.updateDay(0);

    // enable the controls
    this.configureControls();
}

/// Extract useful information from our data.
Visualizer.prototype.aggregateData = function(){
    var maxTotal = 0;
    var maxSingle = 0;
    for(d in this.days){
        var total = 0;
        for(t in this.towns){
            var single = this.days[d][t] || 0;
            total += single;
            maxSingle = Math.max(maxSingle, single);
        }
        this.days[d].total = total;
        maxTotal = Math.max(total, maxTotal);
    }
    this.maxTotal = maxTotal;
    this.maxSingle = maxSingle;
}

/// Prepare the HTML document with the basic frameworks for our view.
Visualizer.prototype.makeView = function(){
    this.makeTable();
    this.makeMap();
}

/// Prepare the HTML document with a basic table.
Visualizer.prototype.makeTable = function(){
    // Find and clear the view target
    $target = this.$view.find(".table-view");
    $target.html('');

    // Make a table
    this.$table = $table = $('<table>', {class:'table table-striped table-condensed'});
    $target.append($table);

    // Header
    $row = $('<tr>');
    $row.append($('<th>Name</th>'));
    $row.append($('<th>Inhabitants</th>'));
    $row.append($('<th>Infected</th>'));
    $row.append($('<th>Percentage</th>'));
    $table.append($row);

    // Rows
    for(town in this.towns){
        $row = $('<tr>', {id:noSpace(town)});
        $row.append($('<td>' + town + '</td>'));
        $row.append($('<td>' + this.towns[town].size + '</td>'));
        $row.append($('<td>', {class:'infected'}));
        $row.append($('<td>', {class:'percent'}));
        $table.append($row);
    }
}

/// Initialize the gradient that governs the node colouring.
Visualizer.prototype.initializeGradient = function($target){
    this.gradient = Gradient.gradients["ultraHeatMap"].scale(this.maxSingle);

    var $legendWrap = $("<div>", {class: "legend"});
    $legendWrap.append("<h3>Legend</h3>");
    this.$legend = $("<div>");
    $legendWrap.append(this.$legend);
    $target.append($legendWrap);
    this.updateLegend();
}

// Updates the legend to match the contents of the selected colour gradient.
Visualizer.prototype.updateLegend = function(){
    this.$legend.html("");
    for(i in this.gradient.colourMap){
        $item = $("<div>", {class: "legend-item"});
        $item.text(Math.round(this.gradient.colourMap[i].val));
        $item.append($("<span>", {class:"legend-circle",style:"background-color:"+this.gradient.colourMap[i].colour.toString()}));
        this.$legend.append($item);
    }
}

/// Prepare the HTML document with a basic table.
Visualizer.prototype.makeMap = function(){
    // Find and clear the view target
    var $target = this.$view.find(".map-view");
    $target.svg("destroy");
    $target.html("");

    this.initializeGradient($target);

    var box = this.findBox();
    var width = 800;
    var height = 800;

    this.sizeFunc = val => Math.sqrt(val) * 8/Math.sqrt(this.maxSingle) + 2;

    // Check if any of the data fits inside a known map.
    for(i in Map.maps){
        theMap = Map.maps[i];
        if(theMap.containsBox(box)){
            console.log("Found map: " + theMap.name);
            box = theMap.box;

            // Find the appropriate size for the map image
            var o = theMap.fitTo(width, height);
            width = o.width;
            height = o.height;

            // Place it on the page
            $img = $("<img>",{src:theMap.imageRef,width:width,height:height});
            $target.append($img);
            break;
        }
    }

    // Functions converting lat/longitudes into percentages.
    var latFunc = lat => (lat - box.minLat) / (box.maxLat - box.minLat);
    var longFunc = long => (long - box.minLong) / (box.maxLong - box.minLong);

    // Make an SVG object
    $target.svg({settings: {width:width,height:height}});
    var svgMap = $target.svg("get");

    // Fill it with circles
    for(town in this.towns){
        // Determine its features
        var x = percentFormat(longFunc(this.towns[town].long));
        var y = percentFormat(1- latFunc(this.towns[town].lat));
        var radius = 5;
        var fillColour = "red";

        // Make and attach the circle
        var dot = svgMap.circle(x, y, radius, {fill: fillColour});

        // Remember the circle
        this.towns[town].dot = dot;

        // Add a little tooltip
        dot.setAttribute("title", town);
        dot.setAttribute("data-toggle", "tooltip");
        dot.setAttribute("data-container", "body");
    }
    refreshTooltips();
}

// Find the box of latitudes/longitudes containing all known locations.
// Returns an object {minLat, maxLat, minLong, maxLong}
Visualizer.prototype.findBox = function(){
    var out = {minLat: 1000, maxLat: -1000, minLong: 1000, maxLong: -1000};

    for(town in this.towns){
        out.minLat = Math.min(this.towns[town].lat, out.minLat);
        out.maxLat = Math.max(this.towns[town].lat, out.maxLat);
        out.minLong = Math.min(this.towns[town].long, out.minLong);
        out.maxLong = Math.max(this.towns[town].long, out.maxLong);
    }

    return out;
}

/// Update the view to match the info at that day.
Visualizer.prototype.updateDay = function(day){
    // clamp day to the valid range
    day = clamp(day, 0, this.maxDays-1);

    this.day = day;
    $('.current-day').text(1 + day);
    this.control.$range.prop("value", day);
    $('.total-infected').text(this.days[day].total);

    this.updateView();
}

/// Update the view to reflect the currently selected day.
Visualizer.prototype.updateView = function(){
    this.updateTable();
    this.updateMap();
}

/// Update the table to reflect the currently selected day.
Visualizer.prototype.updateTable = function(){
    var currentDay = this.days[this.day];

    // Update each column
    for(town in this.towns){
        var count = currentDay[town] || 0;

        // Find the table column for the given town
        var $col = this.$table.find('#' + noSpace(town));

        // Put the amount of infected
        $col.find(".infected").text(count);

        // Write the percentage infected if any
        var percent = count/this.towns[town].size;
        $col.find(".percent").text(percent? percentFormat(percent) : '');
    }
}

/// Update the map to reflect the currently selected day.
Visualizer.prototype.updateMap = function(){
    var currentDay = this.days[this.day];

    for(town in this.towns){
        val = currentDay[town] || 0;
        dot = this.towns[town].dot;
        dot.setAttribute("fill", this.gradient.get(val).toString());
        dot.setAttribute("r", this.sizeFunc(val));
    }
}


//------//
// Etc. //
//------//

// Remove all spaces from a given string.
var noSpace = s => s.split(" ").join('');

// Nicely format a given value p as a percentage showing d digits after the period.
var percentFormat = (p, d=1) => (100*p).toFixed(d)+'%';

// Clamp val to [l, r]
var clamp = (val, l, r) => val > r ? r : val < l ? l : val;

// Refresh Bootstrap's tooltips
var refreshTooltips = () => $('[data-toggle="tooltip"]').tooltip(); 

// Await a certain length of time.
var sleep = ms => new Promise(resolve => setTimeout(resolve, ms));